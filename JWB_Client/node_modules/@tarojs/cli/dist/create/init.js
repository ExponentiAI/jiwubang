"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const chalk_1 = require("chalk");
const child_process_1 = require("child_process");
const ora = require("ora");
const helper = require("../util");
const CONFIG_DIR_NAME = 'config';
const TEMPLATE_CREATOR = 'template_creator.js';
const PACKAGE_JSON_ALIAS = '/pkg';
const styleExtMap = {
    sass: 'scss',
    less: 'less',
    stylus: 'styl',
    none: 'css'
};
const doNotCopyFiles = [
    '.DS_Store',
    '.npmrc',
    TEMPLATE_CREATOR
];
function createFiles(creater, files, handler, options) {
    const { description, projectName, version, css, date, typescript, template, templatePath, projectPath, pageName } = options;
    const logs = [];
    // æ¨¡æ¿åº“æ¨¡æ¿ï¼Œç›´æ¥åˆ›å»ºï¼Œä¸éœ€è¦æ”¹åç¼€
    const globalChangeExt = Boolean(handler);
    const currentStyleExt = styleExtMap[css] || 'css';
    files.forEach(file => {
        // fileRePath startsWith '/'
        const fileRePath = file.replace(templatePath, '').replace(new RegExp(`\\${path.sep}`, 'g'), '/');
        let externalConfig = null;
        // è·‘è‡ªå®šä¹‰é€»è¾‘ï¼Œç¡®å®šæ˜¯å¦åˆ›å»ºæ­¤æ–‡ä»¶
        if (handler && typeof handler[fileRePath] === 'function') {
            externalConfig = handler[fileRePath](options);
            if (!externalConfig)
                return;
        }
        let changeExt = globalChangeExt;
        if (externalConfig && typeof externalConfig === 'object') {
            if (externalConfig.changeExt === false) {
                changeExt = false;
            }
        }
        // åˆå¹¶è‡ªå®šä¹‰ config
        const config = Object.assign({}, {
            description,
            projectName,
            version,
            css,
            cssExt: currentStyleExt,
            date,
            typescript,
            template,
            pageName
        }, externalConfig);
        let destRePath = fileRePath;
        // createPage åˆ›å»ºé¡µé¢æ¨¡å¼
        if (config.setPageName) {
            destRePath = config.setPageName;
        }
        destRePath = destRePath.replace(/^\//, '');
        // å¤„ç† .js å’Œ .css çš„åç¼€
        if (typescript &&
            changeExt &&
            !destRePath.startsWith(`${CONFIG_DIR_NAME}`) &&
            (path.extname(destRePath) === '.js' || path.extname(destRePath) === '.jsx')) {
            destRePath = destRePath.replace('.js', '.ts');
        }
        if (changeExt && path.extname(destRePath).includes('.css')) {
            destRePath = destRePath.replace('.css', `.${currentStyleExt}`);
        }
        let dest = path.join(projectPath, destRePath);
        // å…¼å®¹ Nodejs 13+ è°ƒç”¨ require æ—¶ package.json æ ¼å¼ä¸èƒ½éæ³•
        if (fileRePath === PACKAGE_JSON_ALIAS) {
            dest = path.join(projectPath, 'package.json');
        }
        // åˆ›å»º
        creater.template(template, fileRePath, dest, config);
        logs.push(`${chalk_1.default.green('âœ” ')}${chalk_1.default.grey(`åˆ›å»ºæ–‡ä»¶: ${path.join(projectName, destRePath)}`)}`);
    });
    return logs;
}
function createPage(creater, params, cb) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectDir, template, pageName } = params;
        // path
        const templatePath = creater.templatePath(template);
        if (!fs.existsSync(templatePath))
            return console.log(chalk_1.default.red(`åˆ›å»ºé¡µé¢é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ¨¡æ¿${templatePath}`));
        // å¼•å…¥æ¨¡æ¿ç¼–å†™è€…çš„è‡ªå®šä¹‰é€»è¾‘
        const handlerPath = path.join(templatePath, TEMPLATE_CREATOR);
        const basePageFiles = fs.existsSync(handlerPath) ? require(handlerPath).basePageFiles : [];
        const files = Array.isArray(basePageFiles) ? basePageFiles : [];
        const handler = fs.existsSync(handlerPath) ? require(handlerPath).handler : null;
        const logs = createFiles(creater, files, handler, Object.assign({}, params, { templatePath, projectPath: projectDir, pageName, period: 'createPage' }));
        creater.fs.commit(() => {
            // logs
            console.log();
            logs.forEach(log => console.log(log));
            console.log();
            typeof cb === 'function' && cb();
        });
    });
}
exports.createPage = createPage;
function createApp(creater, params, cb) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectName, projectDir, template, env, autoInstall = true } = params;
        const logs = [];
        // path
        const templatePath = creater.templatePath(template);
        const projectPath = path.join(projectDir, projectName);
        // default æ¨¡æ¿å‘å¸ƒ npm ä¼šæ»¤æ‰ '.' å¼€å¤´çš„æ–‡ä»¶ï¼Œå› æ­¤æ”¹ä¸º '_' å¼€å¤´ï¼Œè¿™é‡Œå…ˆæ”¹å›æ¥ã€‚
        if (env !== 'test' && template === 'default') {
            const files = yield fs.readdir(templatePath);
            const renames = files
                .map(file => {
                const filePath = path.join(templatePath, file);
                if (fs.statSync(filePath).isFile() && file.startsWith('_')) {
                    return fs.rename(filePath, path.join(templatePath, file.replace(/^_/, '.')));
                }
                return Promise.resolve();
            });
            yield Promise.all(renames);
        }
        // npm & yarn
        const version = helper.getPkgVersion();
        const shouldUseYarn = helper.shouldUseYarn();
        const useNpmrc = !shouldUseYarn;
        const yarnLockfilePath = path.join('yarn-lockfiles', `${version}-yarn.lock`);
        const useYarnLock = shouldUseYarn && fs.existsSync(creater.templatePath(template, yarnLockfilePath));
        if (useNpmrc) {
            creater.template(template, '.npmrc', path.join(projectPath, '.npmrc'));
            logs.push(`${chalk_1.default.green('âœ” ')}${chalk_1.default.grey(`åˆ›å»ºæ–‡ä»¶: ${projectName}${path.sep}.npmrc`)}`);
        }
        if (useYarnLock) {
            creater.template(template, yarnLockfilePath, path.join(projectPath, 'yarn.lock'));
            logs.push(`${chalk_1.default.green('âœ” ')}${chalk_1.default.grey(`åˆ›å»ºæ–‡ä»¶: ${projectName}${path.sep}yarn.lock`)}`);
        }
        // éå†å‡ºæ¨¡æ¿ä¸­æ‰€æœ‰æ–‡ä»¶
        const files = yield helper.getAllFilesInFloder(templatePath, doNotCopyFiles);
        // å¼•å…¥æ¨¡æ¿ç¼–å†™è€…çš„è‡ªå®šä¹‰é€»è¾‘
        const handlerPath = path.join(templatePath, TEMPLATE_CREATOR);
        const handler = fs.existsSync(handlerPath) ? require(handlerPath).handler : null;
        // ä¸ºæ‰€æœ‰æ–‡ä»¶è¿›è¡Œåˆ›å»º
        logs.push(...createFiles(creater, files, handler, Object.assign({}, params, { version,
            templatePath,
            projectPath, pageName: 'index', period: 'createApp' })));
        // fs commit
        creater.fs.commit(() => {
            // logs
            console.log();
            console.log(`${chalk_1.default.green('âœ” ')}${chalk_1.default.grey(`åˆ›å»ºé¡¹ç›®: ${chalk_1.default.grey.bold(projectName)}`)}`);
            logs.forEach(log => console.log(log));
            console.log();
            // git init
            const gitInitSpinner = ora(`cd ${chalk_1.default.cyan.bold(projectName)}, æ‰§è¡Œ ${chalk_1.default.cyan.bold('git init')}`).start();
            process.chdir(projectPath);
            const gitInit = child_process_1.exec('git init');
            gitInit.on('close', code => {
                if (code === 0) {
                    gitInitSpinner.color = 'green';
                    gitInitSpinner.succeed(gitInit.stdout.read());
                }
                else {
                    gitInitSpinner.color = 'red';
                    gitInitSpinner.fail(gitInit.stderr.read());
                }
            });
            const callSuccess = () => {
                console.log(chalk_1.default.green(`åˆ›å»ºé¡¹ç›® ${chalk_1.default.green.bold(projectName)} æˆåŠŸï¼`));
                console.log(chalk_1.default.green(`è¯·è¿›å…¥é¡¹ç›®ç›®å½• ${chalk_1.default.green.bold(projectName)} å¼€å§‹å·¥ä½œå§ï¼ğŸ˜`));
                if (typeof cb === 'function') {
                    cb();
                }
            };
            if (autoInstall) {
                // packages install
                let command;
                if (shouldUseYarn) {
                    command = 'yarn install';
                }
                else if (helper.shouldUseCnpm()) {
                    command = 'cnpm install';
                }
                else {
                    command = 'npm install';
                }
                const installSpinner = ora(`æ‰§è¡Œå®‰è£…é¡¹ç›®ä¾èµ– ${chalk_1.default.cyan.bold(command)}, éœ€è¦ä¸€ä¼šå„¿...`).start();
                child_process_1.exec(command, (error, stdout, stderr) => {
                    if (error) {
                        installSpinner.color = 'red';
                        installSpinner.fail(chalk_1.default.red('å®‰è£…é¡¹ç›®ä¾èµ–å¤±è´¥ï¼Œè¯·è‡ªè¡Œé‡æ–°å®‰è£…ï¼'));
                        console.log(error);
                    }
                    else {
                        installSpinner.color = 'green';
                        installSpinner.succeed('å®‰è£…æˆåŠŸ');
                        console.log(`${stderr}${stdout}`);
                    }
                    callSuccess();
                });
            }
            else {
                callSuccess();
            }
        });
    });
}
exports.createApp = createApp;
